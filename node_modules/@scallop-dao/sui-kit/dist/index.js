"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SUI_CLOCK_OBJECT_ID: () => import_sui8.SUI_CLOCK_OBJECT_ID,
  SUI_SYSTEM_STATE_OBJECT_ID: () => import_sui8.SUI_SYSTEM_STATE_OBJECT_ID,
  SuiAccountManager: () => SuiAccountManager,
  SuiKit: () => SuiKit,
  SuiRpcProvider: () => SuiRpcProvider,
  SuiTxBlock: () => SuiTxBlock,
  TransactionBlock: () => import_sui8.TransactionBlock
});
module.exports = __toCommonJS(src_exports);
var import_sui8 = require("@mysten/sui.js");

// src/lib/sui-kit.ts
var import_sui7 = require("@mysten/sui.js");

// src/lib/sui-account-manager/sui-account-manager.ts
var import_sui3 = require("@mysten/sui.js");

// src/lib/sui-account-manager/keypair.ts
var import_sui = require("@mysten/sui.js");
var getDerivePathForSUI = (derivePathParams = {}) => {
  const { accountIndex = 0, isExternal = false, addressIndex = 0 } = derivePathParams;
  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;
};
var getKeyPair = (mnemonics, derivePathParams = {}) => {
  const derivePath = getDerivePathForSUI(derivePathParams);
  return import_sui.Ed25519Keypair.deriveKeypair(mnemonics, derivePath);
};

// src/lib/sui-account-manager/util.ts
var import_sui2 = require("@mysten/sui.js");
var isHex = (str) => /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);
var isBase64 = (str) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);
function fromHEX(hexStr) {
  if (!hexStr) {
    throw new Error("cannot parse empty string to Uint8Array");
  }
  let intArr = hexStr.replace("0x", "").match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16));
  if (!intArr || intArr.length === 0) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
var hexOrBase64ToUint8Array = (str) => {
  if (isHex(str)) {
    return fromHEX(str);
  } else if (isBase64(str)) {
    return (0, import_sui2.fromB64)(str);
  } else {
    throw new Error("The string is not a valid hex or base64 string.");
  }
};
var PRIVATE_KEY_SIZE = 32;
var LEGACY_PRIVATE_KEY_SIZE = 64;
var normalizePrivateKey = (key) => {
  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {
    key = key.slice(0, PRIVATE_KEY_SIZE);
  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {
    return key.slice(1);
  } else if (key.length === PRIVATE_KEY_SIZE) {
    return key;
  }
  throw new Error("invalid secret key");
};

// src/lib/sui-account-manager/crypto.ts
var import_bip39 = require("@scure/bip39");
var import_english = require("@scure/bip39/wordlists/english.js");
var generateMnemonic = (numberOfWords = 24) => {
  const strength = numberOfWords === 12 ? 128 : 256;
  return (0, import_bip39.generateMnemonic)(import_english.wordlist, strength);
};

// src/lib/sui-account-manager/sui-account-manager.ts
var SuiAccountManager = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   */
  constructor({ mnemonics, secretKey } = {}) {
    this.mnemonics = mnemonics || "";
    this.secretKey = secretKey || "";
    if (!this.mnemonics && !this.secretKey) {
      this.mnemonics = generateMnemonic(24);
    }
    this.currentKeyPair = this.secretKey ? import_sui3.Ed25519Keypair.fromSecretKey(
      normalizePrivateKey(hexOrBase64ToUint8Array(this.secretKey))
    ) : getKeyPair(this.mnemonics);
    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.
   * else:
   * it will generate keyPair from the mnemonic with the given derivePathParams.
   */
  getKeyPair(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentKeyPair;
    return getKeyPair(this.mnemonics, derivePathParams);
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.
   * else:
   * it will generate address from the mnemonic with the given derivePathParams.
   */
  getAddress(derivePathParams) {
    if (!derivePathParams || !this.mnemonics)
      return this.currentAddress;
    return getKeyPair(this.mnemonics, derivePathParams).getPublicKey().toSuiAddress();
  }
  /**
   * Switch the current account with the given derivePathParams.
   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.
   */
  switchAccount(derivePathParams) {
    if (this.mnemonics) {
      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);
      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();
    }
  }
};

// src/lib/sui-rpc-provider/sui-rpc-provider.ts
var import_sui5 = require("@mysten/sui.js");

// src/lib/sui-rpc-provider/faucet.ts
var import_sui4 = require("@mysten/sui.js");
var import_ts_retry_promise = require("ts-retry-promise");
var requestFaucet = async (address, provider) => {
  console.log("\nRequesting SUI from faucet for address: ", address);
  const headers = {
    authority: "faucet.testnet.sui.io",
    method: "POST",
    path: "/gas",
    scheme: "https",
    accept: "*/*",
    "accept-encoding": "gzip, deflate, br",
    "accept-language": "zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7",
    "content-length": "105",
    "content-type": "application/json",
    "origin": "chrome-extension://opcgpfmipidbgpenhmajoajpbobppdil",
    cookie: '_ga=GA1.1.2092533979.1664032306; sui_io_cookie={"level":["necessary","analytics"],"revision":0,"data":null,"rfc_cookie":false}; _ga_YKP53WJMB0=GS1.1.1680531285.31.0.1680531334.11.0.0; _ga_0GW4F97GFL=GS1.1.1680826187.125.0.1680826187.60.0.0; __cf_bm=6rPjXUwuzUPy4yDlZuXgDj0v7xLPpUd5z0CFGCoN_YI-1680867579-0-AZMhU7/mKUUbUlOa27LmfW6eIFkBkXsPKqYgWjpjWpj2XzDckgUsRu/pxSRGfvXCspn3w7Df+uO1MR/b+XikJU0=; _cfuvid=zjwCXMmu19KBIVo_L9Qbq4TqFXJpophG3.EvFTxqdf4-1680867579342-0-604800000',
    "sec-ch-ua": '"Google Chrome";v="111", "Not(A:Brand";v="8", "Chromium";v="111"',
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "macOS",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "none",
    "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36"
  };
  const resp = await (0, import_ts_retry_promise.retry)(() => provider.requestSuiFromFaucet(address, headers), {
    backoff: "EXPONENTIAL",
    // overall timeout in 60 seconds
    timeout: 1e3 * 60,
    // skip retry if we hit the rate-limit error
    retryIf: (error) => !(error instanceof import_sui4.FaucetRateLimitError),
    logger: (msg) => console.warn(`Retry requesting faucet: ${msg}`)
  });
  (0, import_sui4.assert)(resp, import_sui4.FaucetResponse, "Request faucet failed\n");
  console.log("Request faucet success\n");
};

// src/lib/sui-rpc-provider/default-chain-configs.ts
var DEFAULT_LOCALHOST_FULLNODE = "http://0.0.0.0:9000";
var DEFAULT_LOCALHOST_FAUCET = "";
var DEFAULT_DEVNET_FULLNODE = "https://fullnode.devnet.sui.io:443";
var DEFAULT_DEVNET_FAUCET = "https://faucet.devnet.sui.io/gas";
var DEFAULT_TESTNET_FULLNODE = "https://fullnode.testnet.sui.io:443";
var DEFAULT_TESTNET_FAUCET = "https://faucet.testnet.sui.io/gas";
var DEFAULT_MAINNET_FULLNODE = "https://fullnode.mainnet.sui.io:443";
var DEFAULT_MAINNET_FAUCET = "";
var getDefaultNetworkParams = (networkType = "devnet") => {
  switch (networkType) {
    case "localhost":
      return {
        fullNode: DEFAULT_LOCALHOST_FULLNODE,
        faucet: DEFAULT_LOCALHOST_FAUCET
      };
    case "testnet":
      return {
        fullNode: DEFAULT_TESTNET_FULLNODE,
        faucet: DEFAULT_TESTNET_FAUCET
      };
    case "mainnet":
      return {
        fullNode: DEFAULT_MAINNET_FULLNODE,
        faucet: DEFAULT_MAINNET_FAUCET
      };
    default:
      return {
        fullNode: DEFAULT_DEVNET_FULLNODE,
        faucet: DEFAULT_DEVNET_FAUCET
      };
  }
};

// src/lib/sui-rpc-provider/sui-rpc-provider.ts
var SuiRpcProvider = class {
  /**
   *
   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localhost', default is 'devnet'
   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
   * @param faucetUrl, the faucet url, default is the preconfig faucet url for the given network type
   */
  constructor({ fullnodeUrl, faucetUrl, networkType } = {}) {
    const defaultNetworkParams = getDefaultNetworkParams(networkType || "devnet");
    this.fullnodeUrl = fullnodeUrl || defaultNetworkParams.fullNode;
    this.faucetUrl = faucetUrl || defaultNetworkParams.faucet;
    const connection = new import_sui5.Connection({
      fullnode: this.fullnodeUrl,
      faucet: this.faucetUrl
    });
    this.provider = new import_sui5.JsonRpcProvider(connection);
  }
  /**
   * Request some SUI from faucet
   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.
   */
  async requestFaucet(addr) {
    return requestFaucet(addr, this.provider);
  }
  async getBalance(addr, coinType) {
    return this.provider.getBalance({ owner: addr, coinType });
  }
  async getObjects(ids) {
    const options = { showContent: true, showDisplay: true, showType: true };
    const objects = await this.provider.multiGetObjects({ ids, options });
    const parsedObjects = objects.map((object) => {
      const objectId = (0, import_sui5.getObjectId)(object);
      const objectType = (0, import_sui5.getObjectType)(object);
      const objectVersion = (0, import_sui5.getObjectVersion)(object);
      const objectFields = (0, import_sui5.getObjectFields)(object);
      const objectDisplay = (0, import_sui5.getObjectDisplay)(object);
      return { objectId, objectType, objectVersion, objectFields, objectDisplay };
    });
    return parsedObjects;
  }
  /**
   * @description Select coins that add up to the given amount.
   * @param addr the address of the owner
   * @param amount the amount that is needed for the coin
   * @param coinType the coin type, default is '0x2::SUI::SUI'
   */
  async selectCoins(addr, amount, coinType = "0x2::SUI::SUI") {
    const coins = await this.provider.getCoins({ owner: addr, coinType });
    let selectedCoins = [];
    let totalAmount = 0;
    const coinsData = coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance));
    for (const coinData of coins.data) {
      selectedCoins.push({
        objectId: coinData.coinObjectId,
        digest: coinData.digest,
        version: coinData.version
      });
      totalAmount = totalAmount + parseInt(coinData.balance);
      if (totalAmount >= amount) {
        break;
      }
    }
    if (!selectedCoins.length) {
      throw new Error("No valid coins found for the transaction.");
    }
    return selectedCoins;
  }
};

// src/lib/sui-tx-builder/sui-tx-block.ts
var import_sui6 = require("@mysten/sui.js");

// src/lib/sui-tx-builder/util.ts
var getDefaultSuiInputType = (value) => {
  if (typeof value === "string" && value.startsWith("0x")) {
    return "object";
  } else if (typeof value === "number" || typeof value === "bigint") {
    return "u64";
  } else if (typeof value === "boolean") {
    return "bool";
  } else {
    return "object";
  }
};

// src/lib/sui-tx-builder/sui-tx-block.ts
var _isMoveVecArg, isMoveVecArg_fn, _convertArgs, convertArgs_fn;
var SuiTxBlock = class {
  constructor() {
    __privateAdd(this, _isMoveVecArg);
    __privateAdd(this, _convertArgs);
    this.txBlock = new import_sui6.TransactionBlock();
  }
  transferSuiToMany(recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error("transferSuiToMany: recipients.length !== amounts.length");
    }
    const tx = this.txBlock;
    const coins = tx.splitCoins(tx.gas, amounts.map((amount) => tx.pure(amount)));
    recipients.forEach((recipient, index) => {
      tx.transferObjects([coins[index]], tx.pure(recipient));
    });
    return this;
  }
  transferSui(recipient, amount) {
    return this.transferSuiToMany([recipient], [amount]);
  }
  transferObjects(objects, recipient) {
    const tx = this.txBlock;
    tx.transferObjects(__privateMethod(this, _convertArgs, convertArgs_fn).call(this, objects), tx.pure(recipient));
    return this;
  }
  // TODO: refactor this to take a list of coins
  takeAmountFromCoins(coins, amount) {
    const tx = this.txBlock;
    const coinObjects = __privateMethod(this, _convertArgs, convertArgs_fn).call(this, coins);
    const mergedCoin = coins.length > 1 ? tx.mergeCoins(coinObjects[0], coinObjects.slice(1)) : coinObjects[0];
    const [sendCoin] = tx.splitCoins(mergedCoin, [tx.pure(amount)]);
    return [sendCoin, mergedCoin];
  }
  splitSUIFromGas(amounts) {
    const tx = this.txBlock;
    return tx.splitCoins(tx.gas, amounts.map((m) => tx.pure(m)));
  }
  splitCoins(coin, amounts) {
    const tx = this.txBlock;
    const coinObject = __privateMethod(this, _convertArgs, convertArgs_fn).call(this, [coin])[0];
    return tx.splitCoins(coinObject, amounts.map((m) => tx.pure(m)));
  }
  splitMultiCoins(coins, amounts) {
    const tx = this.txBlock;
    const coinObjects = __privateMethod(this, _convertArgs, convertArgs_fn).call(this, coins);
    const mergedCoin = coinObjects[0];
    if (coins.length > 1) {
      tx.mergeCoins(mergedCoin, coinObjects.slice(1));
    }
    const splitedCoins = tx.splitCoins(mergedCoin, amounts.map((m) => tx.pure(m)));
    return { splitedCoins, mergedCoin };
  }
  transferCoinToMany(inputCoins, sender, recipients, amounts) {
    if (recipients.length !== amounts.length) {
      throw new Error("transferSuiToMany: recipients.length !== amounts.length");
    }
    const tx = this.txBlock;
    const { splitedCoins, mergedCoin } = this.splitMultiCoins(inputCoins, amounts);
    recipients.forEach((recipient, index) => {
      tx.transferObjects([splitedCoins[index]], tx.pure(recipient));
    });
    tx.transferObjects([mergedCoin], tx.pure(sender));
    return this;
  }
  transferCoin(inputCoins, sender, recipient, amount) {
    return this.transferCoinToMany(inputCoins, sender, [recipient], [amount]);
  }
  /**
   * @description Move call
   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`
   * @param args the arguments of the move call, such as `['0x1', '0x2']`
   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`
   */
  moveCall(target, args = [], typeArgs = []) {
    const regex = /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;
    const match = target.match(regex);
    if (match === null)
      throw new Error("Invalid target format. Expected `${string}::${string}::${string}`");
    const convertedArgs = __privateMethod(this, _convertArgs, convertArgs_fn).call(this, args);
    const tx = this.txBlock;
    return tx.moveCall({
      target,
      arguments: convertedArgs,
      typeArguments: typeArgs
    });
  }
  stakeSui(amount, validatorAddr) {
    const tx = this.txBlock;
    const [stakeCoin] = tx.splitCoins(tx.gas, [tx.pure(amount)]);
    tx.moveCall({
      target: "0x3::sui_system::request_add_stake",
      arguments: [tx.object(import_sui6.SUI_SYSTEM_STATE_OBJECT_ID), stakeCoin, tx.pure(validatorAddr)]
    });
    return tx;
  }
  address(value) {
    return this.txBlock.pure(value);
  }
  pure(value) {
    return this.txBlock.pure(value);
  }
  object(value) {
    return this.txBlock.object(value);
  }
  /**
   * Since we know the elements in the array are the same type
   * If type is not provided, we will try to infer the type from the first element
   * By default,
   *
   * string starting with `0x` =====> object id
   * number, bigint ====> u64
   * boolean =====> bool
   *
   *
   * If type is provided, we will use the type to convert the array
   * @param args
   * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'object'
   */
  makeMoveVec(args, type) {
    if (args.length === 0)
      throw new Error("Transaction builder error: Empty array is not allowed");
    const defaultSuiType = getDefaultSuiInputType(args[0]);
    if (type === "object" || !type && defaultSuiType === "object") {
      const objects = args.map(
        (arg) => typeof arg === "string" ? this.txBlock.object((0, import_sui6.normalizeSuiObjectId)(arg)) : arg
      );
      return this.txBlock.makeMoveVec({ objects });
    } else {
      const vecType = type || defaultSuiType;
      return this.txBlock.pure(args, `vector<${vecType}>`);
    }
  }
};
_isMoveVecArg = new WeakSet();
isMoveVecArg_fn = function(arg) {
  const isFullMoveVecArg = arg && arg.value && Array.isArray(arg.value) && arg.vecType;
  const isSimpleMoveVecArg = Array.isArray(arg);
  return isFullMoveVecArg || isSimpleMoveVecArg;
};
_convertArgs = new WeakSet();
convertArgs_fn = function(args) {
  return args.map((arg) => {
    if (typeof arg === "string" && arg.startsWith("0x")) {
      return this.txBlock.object((0, import_sui6.normalizeSuiObjectId)(arg));
    } else if (__privateMethod(this, _isMoveVecArg, isMoveVecArg_fn).call(this, arg)) {
      const vecType = arg.vecType || void 0;
      return vecType ? this.makeMoveVec(arg.value, vecType) : this.makeMoveVec(arg);
    } else if (typeof arg !== "object") {
      return this.txBlock.pure(arg);
    } else {
      return arg;
    }
  });
};

// src/lib/sui-kit.ts
var SuiKit = class {
  /**
   * Support the following ways to init the SuiToolkit:
   * 1. mnemonics
   * 2. secretKey (base64 or hex)
   * If none of them is provided, will generate a random mnemonics with 24 words.
   *
   * @param mnemonics, 12 or 24 mnemonics words, separated by space
   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored
   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localhost', default is 'devnet'
   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type
   * @param faucetUrl, the faucet url, default is the preconfig faucet url for the given network type
   */
  constructor({ mnemonics, secretKey, networkType, fullnodeUrl, faucetUrl } = {}) {
    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });
    this.rpcProvider = new SuiRpcProvider({ fullnodeUrl, faucetUrl, networkType });
  }
  /**
   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.
   * else:
   * it will generate signer from the mnemonic with the given derivePathParams.
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getSigner(derivePathParams) {
    const keyPair = this.accountManager.getKeyPair(derivePathParams);
    return new import_sui7.RawSigner(keyPair, this.rpcProvider.provider);
  }
  /**
   * @description Switch the current account with the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  switchAccount(derivePathParams) {
    this.accountManager.switchAccount(derivePathParams);
  }
  /**
   * @description Get the address of the account for the given derivePathParams
   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard
   */
  getAddress(derivePathParams) {
    return this.accountManager.getAddress(derivePathParams);
  }
  currentAddress() {
    return this.accountManager.currentAddress;
  }
  provider() {
    return this.rpcProvider.provider;
  }
  /**
   * Request some SUI from faucet
   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.
   */
  async requestFaucet(derivePathParams) {
    const addr = this.accountManager.getAddress(derivePathParams);
    return this.rpcProvider.requestFaucet(addr);
  }
  async getBalance(coinType, derivePathParams) {
    const owner = this.accountManager.getAddress(derivePathParams);
    return this.rpcProvider.getBalance(owner, coinType);
  }
  async getObjects(objectIds) {
    return this.rpcProvider.getObjects(objectIds);
  }
  async signTxn(tx, derivePathParams) {
    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    const signer = this.getSigner(derivePathParams);
    return signer.signTransactionBlock({ transactionBlock: tx });
  }
  async signAndSendTxn(tx, derivePathParams) {
    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    const signer = this.getSigner(derivePathParams);
    return signer.signAndExecuteTransactionBlock({ transactionBlock: tx, options: {
      showEffects: true,
      showEvents: true,
      showObjectChanges: true
    } });
  }
  /**
   * Transfer the given amount of SUI to the recipient
   * @param recipient
   * @param amount
   * @param derivePathParams
   */
  async transferSui(recipient, amount, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferSui(recipient, amount);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer to mutliple recipients
   * @param recipients the recipients addresses
   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients
   * @param derivePathParams
   */
  async transferSuiToMany(recipients, amounts, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferSuiToMany(recipients, amounts);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Transfer the given amounts of coin to multiple recipients
   * @param recipients the list of recipient address
   * @param amounts the amounts to transfer for each recipient
   * @param coinType any custom coin type but not SUI
   * @param derivePathParams the derive path params for the current signer
   */
  async transferCoinToMany(recipients, amounts, coinType, derivePathParams) {
    const tx = new SuiTxBlock();
    const owner = this.accountManager.getAddress(derivePathParams);
    const totalAmount = amounts.reduce((a, b) => a + b, 0);
    const coins = await this.rpcProvider.selectCoins(owner, totalAmount, coinType);
    tx.transferCoinToMany(coins.map((c) => c.objectId), owner, recipients, amounts);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async transferCoin(recipient, amount, coinType, derivePathParams) {
    return this.transferCoinToMany([recipient], [amount], coinType, derivePathParams);
  }
  async transferObjects(objects, recipient, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.transferObjects(objects, recipient);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  async moveCall(callParams) {
    const { target, arguments: args = [], typeArguments = [], derivePathParams } = callParams;
    const tx = new SuiTxBlock();
    tx.moveCall(target, args, typeArguments);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount
   * @param amount
   * @param coinType
   * @param owner
   */
  async selectCoinsWithAmount(amount, coinType, owner) {
    owner = owner || this.accountManager.currentAddress;
    const coins = await this.rpcProvider.selectCoins(owner, amount, coinType);
    return coins.map((c) => c.objectId);
  }
  /**
   * stake the given amount of SUI to the validator
   * @param amount the amount of SUI to stake
   * @param validatorAddr the validator address
   * @param derivePathParams the derive path params for the current signer
   */
  async stakeSui(amount, validatorAddr, derivePathParams) {
    const tx = new SuiTxBlock();
    tx.stakeSui(amount, validatorAddr);
    return this.signAndSendTxn(tx, derivePathParams);
  }
  /**
   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.
   * Since the transaction is not submitted, its gas cost is not charged.
   * @param tx the transaction to execute
   * @param derivePathParams the derive path params
   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.
   */
  async inspectTxn(tx, derivePathParams) {
    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;
    return this.rpcProvider.provider.devInspectTransactionBlock({ transactionBlock: tx, sender: this.getAddress(derivePathParams) });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SUI_CLOCK_OBJECT_ID,
  SUI_SYSTEM_STATE_OBJECT_ID,
  SuiAccountManager,
  SuiKit,
  SuiRpcProvider,
  SuiTxBlock,
  TransactionBlock
});
//# sourceMappingURL=index.js.map