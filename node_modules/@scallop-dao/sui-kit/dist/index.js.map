{"version":3,"sources":["../src/index.ts","../src/lib/sui-kit.ts","../src/lib/sui-account-manager/sui-account-manager.ts","../src/lib/sui-account-manager/keypair.ts","../src/lib/sui-account-manager/util.ts","../src/lib/sui-account-manager/crypto.ts","../src/lib/sui-rpc-provider/sui-rpc-provider.ts","../src/lib/sui-rpc-provider/faucet.ts","../src/lib/sui-rpc-provider/default-chain-configs.ts","../src/lib/sui-tx-builder/sui-tx-block.ts","../src/lib/sui-tx-builder/util.ts"],"sourcesContent":["export { TransactionBlock, SUI_CLOCK_OBJECT_ID, SUI_SYSTEM_STATE_OBJECT_ID } from '@mysten/sui.js'\nexport { SuiKit } from './lib/sui-kit'\nexport type { SuiKitParams } from './lib/sui-kit'\nexport { SuiAccountManager } from './lib/sui-account-manager'\nexport type { DerivePathParams } from './lib/sui-account-manager'\nexport { SuiTxBlock } from './lib/sui-tx-builder'\nexport type { SuiTxArg } from './lib/sui-tx-builder'\n\nexport { SuiRpcProvider } from './lib/sui-rpc-provider'\nexport type { NetworkType } from './lib/sui-rpc-provider'\n","/**\n * @file src.ts\n * @description This file is used to aggregate the tools that used to interact with SUI network.\n * @author IceFox\n * @version 0.1.0\n */\nimport { RawSigner, TransactionBlock, DevInspectResults, SuiTransactionBlockResponse } from '@mysten/sui.js';\nimport { SuiAccountManager, DerivePathParams } from \"./sui-account-manager\";\nimport { SuiRpcProvider, NetworkType } from './sui-rpc-provider';\nimport { SuiTxBlock, SuiTxArg, SuiVecTxArg } from \"./sui-tx-builder\";\n\nexport type SuiKitParams = {\n  mnemonics?: string;\n  secretKey?: string;\n  fullnodeUrl?: string;\n  faucetUrl?: string;\n  networkType?: NetworkType;\n}\n/**\n * @class SuiKit\n * @description This class is used to aggregate the tools that used to interact with SUI network.\n */\nexport class SuiKit {\n\n  public accountManager: SuiAccountManager;\n  public rpcProvider: SuiRpcProvider;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localhost', default is 'devnet'\n   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n   * @param faucetUrl, the faucet url, default is the preconfig faucet url for the given network type\n   */\n  constructor({ mnemonics, secretKey, networkType, fullnodeUrl, faucetUrl }: SuiKitParams = {}) {\n    // Init the account manager\n    this.accountManager = new SuiAccountManager({ mnemonics, secretKey });\n    // Init the rpc provider\n    this.rpcProvider = new SuiRpcProvider({ fullnodeUrl, faucetUrl, networkType });\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentSigner.\n   * else:\n   * it will generate signer from the mnemonic with the given derivePathParams.\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getSigner(derivePathParams?: DerivePathParams) {\n    const keyPair = this.accountManager.getKeyPair(derivePathParams);\n    return new RawSigner(keyPair, this.rpcProvider.provider);\n  }\n\n  /**\n   * @description Switch the current account with the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    this.accountManager.switchAccount(derivePathParams);\n  }\n\n  /**\n   * @description Get the address of the account for the given derivePathParams\n   * @param derivePathParams, such as { accountIndex: 2, isExternal: false, addressIndex: 10 }, comply with the BIP44 standard\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    return this.accountManager.getAddress(derivePathParams);\n  }\n  currentAddress() { return this.accountManager.currentAddress }\n  \n  provider() { return this.rpcProvider.provider }\n\n  /**\n   * Request some SUI from faucet\n   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.\n   */\n  async requestFaucet(derivePathParams?: DerivePathParams) {\n    const addr = this.accountManager.getAddress(derivePathParams);\n    return this.rpcProvider.requestFaucet(addr);\n  }\n\n  async getBalance(coinType?: string, derivePathParams?: DerivePathParams) {\n    const owner = this.accountManager.getAddress(derivePathParams);\n    return this.rpcProvider.getBalance(owner, coinType);\n  }\n\n  async getObjects(objectIds: string[]) {\n    return this.rpcProvider.getObjects(objectIds);\n  }\n\n  async signTxn(tx: Uint8Array | TransactionBlock | SuiTxBlock, derivePathParams?: DerivePathParams) {\n    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    const signer = this.getSigner(derivePathParams);\n    return signer.signTransactionBlock({ transactionBlock: tx });\n  }\n\n  async signAndSendTxn(tx: Uint8Array | TransactionBlock | SuiTxBlock, derivePathParams?: DerivePathParams): Promise<SuiTransactionBlockResponse> {\n    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    const signer = this.getSigner(derivePathParams);\n    return signer.signAndExecuteTransactionBlock({ transactionBlock: tx, options: {\n        showEffects: true,\n        showEvents: true,\n        showObjectChanges: true,\n    }})\n  }\n\n  /**\n   * Transfer the given amount of SUI to the recipient\n   * @param recipient\n   * @param amount\n   * @param derivePathParams\n   */\n  async transferSui(recipient: string, amount: number, derivePathParams?: DerivePathParams) {\n    const tx = new SuiTxBlock();\n    tx.transferSui(recipient, amount);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer to mutliple recipients\n   * @param recipients the recipients addresses\n   * @param amounts the amounts of SUI to transfer to each recipient, the length of amounts should be the same as the length of recipients\n   * @param derivePathParams\n   */\n  async transferSuiToMany(recipients: string[], amounts: number[], derivePathParams?: DerivePathParams) {\n    const tx = new SuiTxBlock();\n    tx.transferSuiToMany(recipients, amounts);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Transfer the given amounts of coin to multiple recipients\n   * @param recipients the list of recipient address\n   * @param amounts the amounts to transfer for each recipient\n   * @param coinType any custom coin type but not SUI\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async transferCoinToMany(recipients: string[], amounts: number[], coinType: string, derivePathParams?: DerivePathParams) {\n    const tx = new SuiTxBlock();\n    const owner = this.accountManager.getAddress(derivePathParams);\n    const totalAmount = amounts.reduce((a, b) => a + b, 0);\n    const coins = await this.rpcProvider.selectCoins(owner, totalAmount, coinType);\n    tx.transferCoinToMany(coins.map(c => c.objectId), owner, recipients, amounts);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n  \n  async transferCoin(recipient: string, amount: number, coinType: string, derivePathParams?: DerivePathParams) {\n    return this.transferCoinToMany([recipient], [amount], coinType, derivePathParams)\n  }\n  \n  async transferObjects(objects: string[], recipient: string, derivePathParams?: DerivePathParams) {\n    const tx = new SuiTxBlock();\n    tx.transferObjects(objects, recipient);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n  \n  async moveCall(callParams: {target: string, arguments?: (SuiTxArg | SuiVecTxArg)[], typeArguments?: string[], derivePathParams?: DerivePathParams}) {\n    const { target, arguments: args = [], typeArguments = [], derivePathParams } = callParams;\n    const tx = new SuiTxBlock();\n    tx.moveCall(target, args, typeArguments);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Select coins with the given amount and coin type, the total amount is greater than or equal to the given amount\n   * @param amount\n   * @param coinType\n   * @param owner\n   */\n  async selectCoinsWithAmount(amount: number, coinType: string, owner?: string) {\n    owner = owner || this.accountManager.currentAddress;\n    const coins = await this.rpcProvider.selectCoins(owner, amount, coinType);\n    return coins.map(c => c.objectId)\n  }\n\n  /**\n   * stake the given amount of SUI to the validator\n   * @param amount the amount of SUI to stake\n   * @param validatorAddr the validator address\n   * @param derivePathParams the derive path params for the current signer\n   */\n  async stakeSui(amount: number, validatorAddr: string, derivePathParams?: DerivePathParams) {\n    const tx = new SuiTxBlock();\n    tx.stakeSui(amount, validatorAddr);\n    return this.signAndSendTxn(tx, derivePathParams);\n  }\n\n  /**\n   * Execute the transaction with on-chain data but without really submitting. Useful for querying the effects of a transaction.\n   * Since the transaction is not submitted, its gas cost is not charged.\n   * @param tx the transaction to execute\n   * @param derivePathParams the derive path params\n   * @returns the effects and events of the transaction, such as object changes, gas cost, event emitted.\n   */\n  async inspectTxn(tx: Uint8Array | TransactionBlock | SuiTxBlock, derivePathParams?: DerivePathParams): Promise<DevInspectResults> {\n    tx = tx instanceof SuiTxBlock ? tx.txBlock : tx;\n    return this.rpcProvider.provider.devInspectTransactionBlock({ transactionBlock: tx, sender: this.getAddress(derivePathParams) })\n  }\n}\n","import { Ed25519Keypair } from '@mysten/sui.js'\nimport { getKeyPair, DerivePathParams } from \"./keypair\";\nimport {hexOrBase64ToUint8Array, normalizePrivateKey} from \"./util\";\nimport { generateMnemonic } from './crypto';\n\ntype AccountMangerParams = {\n  mnemonics?: string;\n  secretKey?: string;\n}\nexport class SuiAccountManager {\n  private mnemonics: string;\n  private secretKey: string;\n  public currentKeyPair: Ed25519Keypair;\n  public currentAddress: string;\n\n  /**\n   * Support the following ways to init the SuiToolkit:\n   * 1. mnemonics\n   * 2. secretKey (base64 or hex)\n   * If none of them is provided, will generate a random mnemonics with 24 words.\n   *\n   * @param mnemonics, 12 or 24 mnemonics words, separated by space\n   * @param secretKey, base64 or hex string, when mnemonics is provided, secretKey will be ignored\n   */\n  constructor({ mnemonics, secretKey }: AccountMangerParams = {}) {\n    // If the mnemonics or secretKey is provided, use it\n    // Otherwise, generate a random mnemonics with 24 words\n    this.mnemonics = mnemonics || \"\";\n    this.secretKey = secretKey || \"\";\n    if (!this.mnemonics && !this.secretKey) {\n      this.mnemonics = generateMnemonic(24)\n    }\n\n    // Init the current account\n    this.currentKeyPair = this.secretKey\n      ? Ed25519Keypair.fromSecretKey(\n        normalizePrivateKey(hexOrBase64ToUint8Array(this.secretKey))\n      )\n      : getKeyPair(this.mnemonics);\n    this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentKeyPair.\n   * else:\n   * it will generate keyPair from the mnemonic with the given derivePathParams.\n   */\n  getKeyPair(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentKeyPair;\n    return getKeyPair(this.mnemonics, derivePathParams);\n  }\n\n  /**\n   * if derivePathParams is not provided or mnemonics is empty, it will return the currentAddress.\n   * else:\n   * it will generate address from the mnemonic with the given derivePathParams.\n   */\n  getAddress(derivePathParams?: DerivePathParams) {\n    if (!derivePathParams || !this.mnemonics) return this.currentAddress;\n    return getKeyPair(this.mnemonics, derivePathParams).getPublicKey().toSuiAddress();\n  }\n\n  /**\n   * Switch the current account with the given derivePathParams.\n   * This is only useful when the mnemonics is provided. For secretKey mode, it will always use the same account.\n   */\n  switchAccount(derivePathParams: DerivePathParams) {\n    if (this.mnemonics) {\n      this.currentKeyPair = getKeyPair(this.mnemonics, derivePathParams);\n      this.currentAddress = this.currentKeyPair.getPublicKey().toSuiAddress();\n    }\n  }\n}\n","import { Ed25519Keypair } from '@mysten/sui.js'\n\nexport type DerivePathParams = {\n  accountIndex?: number;\n  isExternal?: boolean;\n  addressIndex?: number;\n}\n/**\n * @description Get ed25519 derive path for SUI\n * @param derivePathParams\n */\nexport const getDerivePathForSUI = (derivePathParams: DerivePathParams = {}) => {\n  const { accountIndex = 0, isExternal = false, addressIndex = 0 } = derivePathParams;\n  return `m/44'/784'/${accountIndex}'/${isExternal ? 1 : 0}'/${addressIndex}'`;\n}\n\n/**\n * the format is m/44'/784'/accountIndex'/${isExternal ? 1 : 0}'/addressIndex'\n *\n * accountIndex is the index of the account, default is 0.\n *\n * isExternal is the type of the address, default is false. Usually, the external address is used to receive coins. The internal address is used to change coins.\n *\n * addressIndex is the index of the address, default is 0. It's used to generate multiple addresses for one account.\n *\n * @description Get keypair from mnemonics and derive path\n * @param mnemonics\n * @param derivePathParams\n */\nexport const getKeyPair = (mnemonics: string, derivePathParams: DerivePathParams = {}) => {\n  const derivePath = getDerivePathForSUI(derivePathParams);\n  return Ed25519Keypair.deriveKeypair(mnemonics, derivePath);\n}\n","import { fromB64 } from '@mysten/sui.js'\n/**\n * @description This regular expression matches any string that contains only hexadecimal digits (0-9, A-F, a-f).\n * @param str\n */\nexport const isHex = (str: string) => /^0x[0-9a-fA-F]+$|^[0-9a-fA-F]+$/.test(str);\n\n/**\n * @description This regular expression matches any string that contains only base64 digits (0-9, A-Z, a-z, +, /, =).\n * Note that the \"=\" signs at the end are optional padding characters that may be present in some base64 encoded strings.\n * @param str\n */\nexport const isBase64 = (str: string) => /^[a-zA-Z0-9+/]+={0,2}$/g.test(str);\n\n/**\n * Convert a hex string to Uint8Array\n * @param hexStr\n */\nexport function fromHEX(hexStr: string): Uint8Array {\n  if (!hexStr) {\n    throw new Error('cannot parse empty string to Uint8Array')\n  }\n  let intArr = hexStr\n    .replace('0x', '')\n    .match(/.{1,2}/g)?.map(byte => parseInt(byte, 16));\n\n  if (!intArr || intArr.length === 0) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\n\n/**\n * @description Convert a hex or base64 string to Uint8Array\n */\nexport const hexOrBase64ToUint8Array = (str: string): Uint8Array => {\n  if (isHex(str)) {\n    return fromHEX(str)\n  } else if (isBase64(str)) {\n    return fromB64(str)\n  } else {\n    throw new Error('The string is not a valid hex or base64 string.');\n  }\n}\n\nconst PRIVATE_KEY_SIZE = 32;\nconst LEGACY_PRIVATE_KEY_SIZE = 64;\n/**\n * normalize a private key\n * A private key is a 32-byte array.\n * But there are two different formats for private keys:\n * 1. A 32-byte array\n * 2. A 64-byte array with the first 32 bytes being the private key and the last 32 bytes being the public key\n * 3. A 33-byte array with the first byte being 0x00 (sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning)\n */\nexport const normalizePrivateKey = (key: Uint8Array): Uint8Array => {\n  if (key.length === LEGACY_PRIVATE_KEY_SIZE) {\n    // This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n    key = key.slice(0, PRIVATE_KEY_SIZE);\n  } else if (key.length === PRIVATE_KEY_SIZE + 1 && key[0] === 0) {\n    // sui.keystore key is a Base64 string with scheme flag 0x00 at the beginning\n    return key.slice(1);\n  } else if (key.length === PRIVATE_KEY_SIZE) {\n    return key;\n  }\n  throw new Error('invalid secret key');\n}\n","import { generateMnemonic as genMnemonic } from '@scure/bip39'\nimport { wordlist } from '@scure/bip39/wordlists/english.js'\n\nexport const generateMnemonic = (numberOfWords: 12 | 24 = 24) => {\n  const strength = numberOfWords === 12 ? 128 : 256\n  return genMnemonic(wordlist, strength)\n}\n","import {\n  Connection,\n  JsonRpcProvider,\n  getObjectType,\n  getObjectId,\n  getObjectFields,\n  getObjectDisplay,\n  getObjectVersion,\n  DisplayFieldsResponse,\n  ObjectContentFields,\n} from \"@mysten/sui.js\";\nimport { requestFaucet } from './faucet'\nimport { NetworkType, getDefaultNetworkParams } from \"./default-chain-configs\";\n\ntype ObjectData = {\n  objectId: string;\n  objectType: string;\n  objectVersion: number;\n  objectDisplay: DisplayFieldsResponse;\n  objectFields: ObjectContentFields;\n}\n\ntype Params = {\n  fullnodeUrl?: string;\n  faucetUrl?: string;\n  networkType?: NetworkType;\n}\n\nexport class SuiRpcProvider {\n  public fullnodeUrl: string;\n  public faucetUrl: string;\n  public provider: JsonRpcProvider;\n  /**\n   *\n   * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localhost', default is 'devnet'\n   * @param fullnodeUrl, the fullnode url, default is the preconfig fullnode url for the given network type\n   * @param faucetUrl, the faucet url, default is the preconfig faucet url for the given network type\n   */\n  constructor({ fullnodeUrl, faucetUrl, networkType }: Params = {}) {\n    // Get the default fullnode url and faucet url for the given network type, default is 'testnet'\n    const defaultNetworkParams = getDefaultNetworkParams(networkType || 'devnet');\n    // Set fullnodeUrl and faucetUrl, if they are not provided, use the default value.\n    this.fullnodeUrl = fullnodeUrl || defaultNetworkParams.fullNode;\n    this.faucetUrl = faucetUrl || defaultNetworkParams.faucet;\n\n    // Init the provider\n    const connection = new Connection({\n      fullnode: this.fullnodeUrl,\n      faucet: this.faucetUrl,\n    });\n    this.provider = new JsonRpcProvider(connection);\n  }\n\n  /**\n   * Request some SUI from faucet\n   * @Returns {Promise<boolean>}, true if the request is successful, false otherwise.\n   */\n  async requestFaucet(addr: string) {\n    return requestFaucet(addr, this.provider)\n  }\n\n  async getBalance(addr: string, coinType?: string) {\n    return this.provider.getBalance({ owner: addr, coinType });\n  }\n\n  async getObjects(ids: string[]) {\n    const options = { showContent: true, showDisplay: true, showType: true };\n    const objects = await this.provider.multiGetObjects({ ids, options });\n    const parsedObjects = objects.map((object) => {\n      const objectId = getObjectId(object);\n      const objectType = getObjectType(object);\n      const objectVersion = getObjectVersion(object);\n      const objectFields = getObjectFields(object);\n      const objectDisplay = getObjectDisplay(object);\n      return { objectId, objectType, objectVersion, objectFields, objectDisplay };\n    });\n    return parsedObjects as ObjectData[]\n  }\n\n  /**\n   * @description Select coins that add up to the given amount.\n   * @param addr the address of the owner\n   * @param amount the amount that is needed for the coin\n   * @param coinType the coin type, default is '0x2::SUI::SUI'\n   */\n  async selectCoins(addr: string, amount: number, coinType: string = '0x2::SUI::SUI') {\n    const coins = await this.provider.getCoins({ owner: addr, coinType });\n    let selectedCoins: {objectId: string, digest: string, version: string}[] = [];\n    let totalAmount = 0;\n    // Sort the coins by balance in descending order\n    const coinsData = coins.data.sort((a, b) => parseInt(b.balance) - parseInt(a.balance))\n    for(const coinData of coins.data) {\n      selectedCoins.push({\n        objectId: coinData.coinObjectId,\n        digest: coinData.digest,\n        version: coinData.version,\n      });\n      totalAmount = totalAmount + parseInt(coinData.balance);\n      if (totalAmount >= amount) {\n        break;\n      }\n    }\n\n    if (!selectedCoins.length) {\n      throw new Error('No valid coins found for the transaction.');\n    }\n    return selectedCoins;\n  }\n}\n","import {JsonRpcProvider, FaucetRateLimitError, assert, FaucetResponse} from '@mysten/sui.js'\nimport { retry } from 'ts-retry-promise'\n\n/**\n * Request some SUI from faucet\n * @param address\n * @param provider\n * @returns {Promise<boolean>}, return true if the request is successful\n */\nexport const requestFaucet = async (address: string, provider: JsonRpcProvider) => {\n  console.log('\\nRequesting SUI from faucet for address: ', address)\n  const headers = {\n    authority: 'faucet.testnet.sui.io',\n    method: 'POST',\n    path: '/gas',\n    scheme: 'https',\n    accept: '*/*',\n    'accept-encoding': 'gzip, deflate, br',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7',\n    'content-length': '105',\n    'content-type': 'application/json',\n    'origin': 'chrome-extension://opcgpfmipidbgpenhmajoajpbobppdil',\n    cookie: '_ga=GA1.1.2092533979.1664032306; sui_io_cookie={\"level\":[\"necessary\",\"analytics\"],\"revision\":0,\"data\":null,\"rfc_cookie\":false}; _ga_YKP53WJMB0=GS1.1.1680531285.31.0.1680531334.11.0.0; _ga_0GW4F97GFL=GS1.1.1680826187.125.0.1680826187.60.0.0; __cf_bm=6rPjXUwuzUPy4yDlZuXgDj0v7xLPpUd5z0CFGCoN_YI-1680867579-0-AZMhU7/mKUUbUlOa27LmfW6eIFkBkXsPKqYgWjpjWpj2XzDckgUsRu/pxSRGfvXCspn3w7Df+uO1MR/b+XikJU0=; _cfuvid=zjwCXMmu19KBIVo_L9Qbq4TqFXJpophG3.EvFTxqdf4-1680867579342-0-604800000',\n    'sec-ch-ua': '\"Google Chrome\";v=\"111\", \"Not(A:Brand\";v=\"8\", \"Chromium\";v=\"111\"',\n    'sec-ch-ua-mobile': '?0',\n    'sec-ch-ua-platform': \"macOS\",\n    'sec-fetch-dest': 'empty',\n    'sec-fetch-mode': 'cors',\n    'sec-fetch-site': 'none',\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36',\n  }\n  // We need to add the following headers to the request, otherwise the request will be rejected by the faucet server\n  const resp = await retry<FaucetResponse>(() => provider.requestSuiFromFaucet(address, headers), {\n    backoff: 'EXPONENTIAL',\n    // overall timeout in 60 seconds\n    timeout: 1000 * 60,\n    // skip retry if we hit the rate-limit error\n    retryIf: (error: any) => !(error instanceof FaucetRateLimitError),\n    logger: (msg) => console.warn(`Retry requesting faucet: ${msg}`),\n  });\n  assert(resp, FaucetResponse, 'Request faucet failed\\n');\n  console.log('Request faucet success\\n');\n}\n","/**\n * @description This file is used to store the default chain parameters for the different networks.\n * @author IceFox@Scallop\n */\n// For localhost\nexport const DEFAULT_LOCALHOST_FULLNODE = \"http://0.0.0.0:9000\"\nexport const DEFAULT_LOCALHOST_FAUCET = \"\"\n\n// For devnet\nexport const DEFAULT_DEVNET_FULLNODE =\"https://fullnode.devnet.sui.io:443\"\nexport const DEFAULT_DEVNET_FAUCET = \"https://faucet.devnet.sui.io/gas\"\n\n// For testnet\nexport const DEFAULT_TESTNET_FULLNODE = \"https://fullnode.testnet.sui.io:443\"\nexport const DEFAULT_TESTNET_FAUCET = \"https://faucet.testnet.sui.io/gas\"\n\n// For mainnet\nexport const DEFAULT_MAINNET_FULLNODE = \"https://fullnode.mainnet.sui.io:443\"\nexport const DEFAULT_MAINNET_FAUCET = \"\"\n\n\nexport type NetworkType = 'testnet' | 'mainnet' | 'devnet' | 'localhost';\n\n/**\n * @description Get the default fullnode url and faucet url for the given network type\n * @param networkType, 'testnet' | 'mainnet' | 'devnet' | 'localhost', default is 'devnet'\n * @returns { fullNode: string, faucet: string }\n  */\nexport const getDefaultNetworkParams = (networkType: NetworkType = 'devnet'): { fullNode: string, faucet: string } => {\n  switch (networkType) {\n    case 'localhost':\n      return {\n        fullNode: DEFAULT_LOCALHOST_FULLNODE,\n        faucet: DEFAULT_LOCALHOST_FAUCET,\n      }\n    case 'testnet':\n      return {\n        fullNode: DEFAULT_TESTNET_FULLNODE,\n        faucet: DEFAULT_TESTNET_FAUCET,\n      }\n    case 'mainnet':\n      return {\n        fullNode: DEFAULT_MAINNET_FULLNODE,\n        faucet: DEFAULT_MAINNET_FAUCET,\n      }\n    default:\n      return {\n        fullNode: DEFAULT_DEVNET_FULLNODE,\n        faucet: DEFAULT_DEVNET_FAUCET,\n      }\n  }\n}\n","import {\n  TransactionBlock,\n  SUI_SYSTEM_STATE_OBJECT_ID,\n  normalizeSuiObjectId,\n  TransactionArgument,\n} from '@mysten/sui.js'\nimport { SuiInputTypes, getDefaultSuiInputType } from './util'\n\nexport type SuiTxArg = TransactionArgument | string | number | bigint | boolean;\nexport type SuiVecTxArg = { value: SuiTxArg[], vecType: SuiInputTypes } | SuiTxArg[];\n\nexport class SuiTxBlock {\n  public txBlock: TransactionBlock;\n  constructor() {\n    this.txBlock = new TransactionBlock();\n  }\n\n  transferSuiToMany(recipients: string[], amounts: number[]) {\n    // require recipients.length === amounts.length\n    if (recipients.length !== amounts.length) {\n      throw new Error('transferSuiToMany: recipients.length !== amounts.length');\n    }\n    const tx = this.txBlock;\n    const coins = tx.splitCoins(tx.gas, amounts.map(amount => tx.pure(amount)));\n    recipients.forEach((recipient, index) => {\n      tx.transferObjects([coins[index]], tx.pure(recipient));\n    });\n    return this;\n  }\n  transferSui(recipient: string, amount: number) {\n    return this.transferSuiToMany([recipient], [amount]);\n  }\n\n  transferObjects(objects: SuiTxArg[], recipient: string) {\n    const tx = this.txBlock;\n    tx.transferObjects(this.#convertArgs(objects), tx.pure(recipient));\n    return this;\n  }\n\n  // TODO: refactor this to take a list of coins\n  takeAmountFromCoins(coins: SuiTxArg[], amount: number) {\n    const tx = this.txBlock;\n    const coinObjects = this.#convertArgs(coins);\n    const mergedCoin = coins.length > 1\n      ? tx.mergeCoins(coinObjects[0],  coinObjects.slice(1))\n      : coinObjects[0]\n    const [sendCoin] = tx.splitCoins(mergedCoin, [tx.pure(amount)]);\n    return [sendCoin, mergedCoin]\n  }\n\n  splitSUIFromGas(amounts: number[]) {\n    const tx = this.txBlock;\n    return tx.splitCoins(tx.gas, amounts.map(m => tx.pure(m)));\n  }\n  \n  splitCoins(coin: SuiTxArg, amounts: number[]) {\n    const tx = this.txBlock;\n    const coinObject = this.#convertArgs([coin])[0];\n    return tx.splitCoins(coinObject, amounts.map(m => tx.pure(m)));\n  }\n  \n  splitMultiCoins(coins: SuiTxArg[], amounts: number[]) {\n    const tx = this.txBlock;\n    const coinObjects = this.#convertArgs(coins);\n    const mergedCoin = coinObjects[0];\n    if (coins.length > 1) {\n      tx.mergeCoins(mergedCoin,  coinObjects.slice(1));\n    }\n    const splitedCoins = tx.splitCoins(mergedCoin, amounts.map(m => tx.pure(m)));\n    return { splitedCoins, mergedCoin }\n  }\n  \n  transferCoinToMany(inputCoins: SuiTxArg[], sender: string, recipients: string[], amounts: number[]) {\n    // require recipients.length === amounts.length\n    if (recipients.length !== amounts.length) {\n      throw new Error('transferSuiToMany: recipients.length !== amounts.length');\n    }\n    const tx = this.txBlock;\n    const { splitedCoins, mergedCoin } = this.splitMultiCoins(inputCoins, amounts);\n    recipients.forEach((recipient, index) => {\n      tx.transferObjects([splitedCoins[index]], tx.pure(recipient));\n    });\n    tx.transferObjects([mergedCoin], tx.pure(sender))\n    return this;\n  }\n  \n  transferCoin(inputCoins: SuiTxArg[], sender: string, recipient: string, amount: number) {\n    return this.transferCoinToMany(inputCoins, sender, [recipient], [amount]);\n  }\n  \n  /**\n   * @description Move call\n   * @param target `${string}::${string}::${string}`, e.g. `0x3::sui_system::request_add_stake`\n   * @param args the arguments of the move call, such as `['0x1', '0x2']`\n   * @param typeArgs the type arguments of the move call, such as `['0x2::sui::SUI']`\n   */\n  moveCall(target: string, args: (SuiTxArg | SuiVecTxArg)[] = [], typeArgs: string[] = []) {\n    // a regex for pattern `${string}::${string}::${string}`\n    const regex = /(?<package>[a-zA-Z0-9]+)::(?<module>[a-zA-Z0-9_]+)::(?<function>[a-zA-Z0-9_]+)/;\n    const match = target.match(regex);\n    if (match === null) throw new Error('Invalid target format. Expected `${string}::${string}::${string}`');\n    const convertedArgs = this.#convertArgs(args);\n    const tx = this.txBlock;\n    return tx.moveCall({\n      target: target as `${string}::${string}::${string}`,\n      arguments: convertedArgs,\n      typeArguments: typeArgs,\n    });\n  }\n\n  stakeSui(amount: number, validatorAddr: string) {\n    const tx = this.txBlock;\n    const [stakeCoin] = tx.splitCoins(tx.gas, [tx.pure(amount)]);\n    tx.moveCall({\n      target: '0x3::sui_system::request_add_stake',\n      arguments: [tx.object(SUI_SYSTEM_STATE_OBJECT_ID), stakeCoin, tx.pure(validatorAddr)],\n    });\n    return tx;\n  }\n\n  address(value: string) {\n    return this.txBlock.pure(value)\n  }\n\n  pure(value: any) {\n    return this.txBlock.pure(value)\n  }\n\n  object(value: string) {\n    return this.txBlock.object(value)\n  }\n\n  /**\n   * Since we know the elements in the array are the same type\n   * If type is not provided, we will try to infer the type from the first element\n   * By default,\n   *\n   * string starting with `0x` =====> object id\n   * number, bigint ====> u64\n   * boolean =====> bool\n   *\n   *\n   * If type is provided, we will use the type to convert the array\n   * @param args\n   * @param type 'address' | 'bool' | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'u256' | 'object'\n   */\n  makeMoveVec(args: SuiTxArg[], type?: SuiInputTypes) {\n    if (args.length === 0) throw new Error('Transaction builder error: Empty array is not allowed');\n    const defaultSuiType = getDefaultSuiInputType(args[0])\n    if (type === 'object' || (!type && defaultSuiType === 'object')) {\n      const objects = args.map(arg =>\n        typeof arg === 'string' ? this.txBlock.object(normalizeSuiObjectId(arg)) : (arg as any)\n      );\n      return this.txBlock.makeMoveVec({ objects })\n    } else {\n      const vecType = type || defaultSuiType;\n      return this.txBlock.pure(args, `vector<${vecType}>`)\n    }\n  }\n\n  #isMoveVecArg(arg: any) {\n    const isFullMoveVecArg = arg && arg.value && Array.isArray(arg.value) && arg.vecType;\n    const isSimpleMoveVecArg = Array.isArray(arg);\n    return isFullMoveVecArg || isSimpleMoveVecArg;\n  }\n\n  #convertArgs(args: any[]): TransactionArgument[] {\n    return args.map(arg => {\n      if (typeof arg === 'string' && arg.startsWith('0x')) {\n        // We always treat string starting with `0x` as object id\n        return this.txBlock.object(normalizeSuiObjectId(arg))\n      } else if (this.#isMoveVecArg(arg)) {\n        // if it's an array arg, we will convert it to move vec\n        const vecType = arg.vecType || undefined;\n        return vecType\n          ? this.makeMoveVec(arg.value, vecType)\n          : this.makeMoveVec(arg)\n      } else if (typeof arg !== 'object') {\n        // Other basic types such as string, number, boolean are converted to pure value\n        return this.txBlock.pure(arg)\n      } else {\n        // We do nothing, because it's most likely already a move value\n        return arg\n      }\n    })\n  }\n}\n","/**\n * These are the basics types that can be used in the SUI\n */\nexport type SuiBasicTypes =\n  |'address'\n  |'bool'\n  |'u8'\n  | 'u16'\n  | 'u32'\n  | 'u64'\n  | 'u128'\n  | 'u256'\n\nexport type SuiInputTypes = 'object' | SuiBasicTypes\n\nexport const getDefaultSuiInputType = (value: any): SuiInputTypes => {\n  if (typeof value === 'string' && value.startsWith('0x')) {\n    return 'object'\n  } else if (typeof value === 'number' || typeof value === 'bigint') {\n    return 'u64'\n  } else if (typeof value === 'boolean') {\n    return 'bool'\n  } else {\n    return 'object'\n  }\n}\n"],"mappings":"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","names":["import_sui","import_sui","import_sui","import_sui","genMnemonic","import_sui","import_sui","import_sui"]}